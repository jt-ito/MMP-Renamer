import React, { useEffect, useState, useRef, useCallback } from 'react'
import axios from 'axios'
import { FixedSizeList as List } from 'react-window'
import ToastContainer from './components/Toast'
import Settings from './Settings'

function IconRefresh(){
  return (<svg className="icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21 12a9 9 0 10-3 6.75" stroke="currentColor" strokeWidth="1.6" strokeLinecap="round" strokeLinejoin="round"/></svg>)
}

function IconCopy(){
  return (<svg className="icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="9" y="9" width="10" height="10" rx="2" stroke="currentColor" strokeWidth="1.6"/><rect x="4" y="4" width="10" height="10" rx="2" stroke="currentColor" strokeWidth="1.6"/></svg>)
}

function IconApply(){
  return (<svg className="icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 13l4 4L19 7" stroke="currentColor" strokeWidth="1.6" strokeLinecap="round" strokeLinejoin="round"/></svg>)
}

const API = (path) => `/api${path}`

function useLocalState(key, initial) {
  const [s, setS] = useState(() => {
    try { const v = localStorage.getItem(key); return v ? JSON.parse(v) : initial } catch { return initial }
  })
  useEffect(() => { try { localStorage.setItem(key, JSON.stringify(s)) } catch {} }, [key, s])
  return [s, setS]
}

export default function App() {
  const [libraries, setLibraries] = useState([])
  const [scanId, setScanId] = useState(null)
  const [scanMeta, setScanMeta] = useState(null)
  const [items, setItems] = useState([]) // client loaded window
  const [total, setTotal] = useState(0)
  const [visibleOffset, setVisibleOffset] = useLocalState('visibleOffset', 0)
  const [visibleCount, setVisibleCount] = useLocalState('visibleCount', 12)
  const [theme, setTheme] = useLocalState('theme', 'dark')
  const batchSize = 12
  const listRef = useRef()
  const enrichCacheRef = useRef(() => ({}))
  const [enrichCache, setEnrichCache] = useLocalState('enrichCache', {})
  useEffect(() => { enrichCacheRef.current = { ...enrichCache } }, [enrichCache])
  useEffect(() => { try { document.documentElement.classList.toggle('light', theme === 'light') } catch (e) {} }, [theme])

  const [logs, setLogs] = useState('')
  const [toasts, setToasts] = useState([])

  function pushToast(title, message){
    const id = Math.random().toString(36).slice(2,9)
    setToasts(t => [...t, { id, title, message }])
    setTimeout(() => setToasts(t => t.filter(x => x.id !== id)), 6000)
  }

  useEffect(() => { axios.get(API('/libraries')).then(r => setLibraries(r.data)) }, [])

  async function triggerScan(lib) {
    const path = lib?.canonicalPath || '.'
    const r = await axios.post(API('/scan'), { libraryId: lib?.id, path })
    setScanId(r.data.scanId)
    const meta = await axios.get(API(`/scan/${r.data.scanId}`))
    setScanMeta(meta.data)
    setTotal(meta.data.totalCount)
    // load initial window after scan completes
    setVisibleOffset(0)
    setVisibleCount(batchSize)
    const page = await axios.get(API(`/scan/${r.data.scanId}/items?offset=0&limit=${batchSize}`))
    setItems(page.data.items)
    // hydration: pull cached enrichments for visible
    for (const it of page.data.items) {
      const key = it.canonicalPath
      if (enrichCache[key]) continue
      // do not enrich immediately—only when visible (we're visible already)
      enrichOne(it)
    }
  }

  async function enrichOne(item) {
    const key = item.canonicalPath
    try {
      // check server cache
      const r = await axios.get(API(`/enrich`), { params: { path: key } })
      if (r.data.cached) {
        setEnrichCache(prev => ({ ...prev, [key]: r.data.enrichment }))
        return
      }
      const w = await axios.post(API('/enrich'), { path: key })
      setEnrichCache(prev => ({ ...prev, [key]: w.data.enrichment }))
    } catch (err) {
      setEnrichCache(prev => ({ ...prev, [key]: { error: err.message } }))
    }
  }

  // progressive append when scrolling near end
  const handleScrollNearEnd = useCallback(async () => {
    if (!scanId) return
    const nextOffset = items.length
    if (nextOffset >= total) return
    const r = await axios.get(API(`/scan/${scanId}/items?offset=${nextOffset}&limit=${batchSize}`))
    setItems(prev => [...prev, ...r.data.items])
    // enrich newly visible ones lazily
    for (const it of r.data.items) enrichOne(it)
  }, [scanId, items, total])

  // preview rename for selected items
  async function previewRename(selected, template) {
    const r = await axios.post(API('/rename/preview'), { items: selected, template })
    return r.data.plans
  }

  async function applyRename(plans, dryRun = false) {
    const r = await axios.post(API('/rename/apply'), { plans, dryRun })
    return r.data.results
  }

  async function fetchLogs() { const r = await axios.get(API('/logs/recent')); setLogs(r.data.logs) }

  useEffect(() => { fetchLogs(); const t = setInterval(fetchLogs, 3000); return () => clearInterval(t) }, [])

  const [route, setRoute] = useState(window.location.hash || '#/')
  useEffect(() => { const onHash = () => setRoute(window.location.hash || '#/'); window.addEventListener('hashchange', onHash); return () => window.removeEventListener('hashchange', onHash) }, [])

  return (
    <div className="app">
      <header>
        <h1>MMP Renamer</h1>
        <div className="header-actions">
          <button className="btn-ghost" onClick={() => triggerScan(libraries[0])}><span>Scan</span></button>
          <button className="btn-ghost icon-only" onClick={fetchLogs}><IconRefresh /></button>
          <button className="btn-ghost" onClick={() => setTheme(t => t === 'dark' ? 'light' : 'dark')}>Theme: {theme === 'dark' ? 'Dark' : 'Light'}</button>
          <button className="btn-ghost" onClick={() => window.location.hash = '#/settings'}>Settings</button>
        </div>
      </header>

      <main>
        {route === '#/settings' ? (
          <section className="list">
            <Settings pushToast={pushToast} />
          </section>
        ) : (
          <>
            <section className="list">
              {scanMeta ? (
                <div>Found {total} items. Showing {items.length} loaded items.</div>
              ) : (<div>No scan yet</div>)}

              <VirtualizedList items={items} enrichCache={enrichCache} onNearEnd={handleScrollNearEnd} enrichOne={enrichOne}
                previewRename={previewRename} applyRename={applyRename} pushToast={pushToast} />
            </section>
            <aside className="side">
              <LogsPanel logs={logs} refresh={fetchLogs} pushToast={pushToast} />
            </aside>
          </>
        )}
      </main>

      <ToastContainer toasts={toasts} remove={(id)=>setToasts(t=>t.filter(x=>x.id!==id))} />
    </div>
  )
}

function LogsPanel({ logs, refresh, pushToast }) {
  return (
    <div className="logs">
      <h3>Logs</h3>
      <pre>{logs}</pre>
      <div style={{display:'flex',gap:8,marginTop:8, alignItems:'center'}}>
        <button className="btn-ghost icon-only" onClick={refresh} title="Refresh logs"><IconRefresh/></button>
        <button className="btn-ghost icon-only" onClick={() => { navigator.clipboard?.writeText(logs); pushToast('Logs', 'Copied to clipboard') }} title="Copy logs"><IconCopy/></button>
      </div>
    </div>
  )
}

function VirtualizedList({ items, enrichCache, onNearEnd, enrichOne, previewRename, applyRename, pushToast }) {
  const Row = ({ index, style }) => {
    const it = items[index]
    const enrichment = enrichCache[it.canonicalPath]
    useEffect(() => { // when row mounts, ensure enrichment
      if (!enrichment) enrichOne(it)
    }, [])
    return (
      <div className="row" style={style}>
        <div className="meta">
          <div className="path">{it.canonicalPath}</div>
          <div className="title">{enrichment?.title || enrichment?.parsedName || ''}</div>
        </div>
        <div className="actions">
          <button className="btn-apply icon-btn" onClick={async () => {
            const plans = await previewRename([it], '{title}');
            pushToast('Preview ready', 'Rename plan generated — applying now')
            const res = await applyRename(plans);
            pushToast('Apply result', JSON.stringify(res))
          }}><IconApply/> <span>Apply</span></button>
        </div>
      </div>
    )
  }

  // simple near-end detection
  function onItemsRendered({ visibleStopIndex }) {
    if (visibleStopIndex >= items.length - 3) onNearEnd()
  }

  return (
    <List height={600} itemCount={items.length} itemSize={80} width={'100%'} onItemsRendered={onItemsRendered}>
      {Row}
    </List>
  )
}
